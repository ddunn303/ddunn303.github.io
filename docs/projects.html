<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Projects – ddunn303.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-fd053a38988e21bb3d3b0b617a2084cf.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">ddunn303.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./projects.html" aria-current="page"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projects</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<section id="nps-projects" class="level2">
<h2 class="anchored" data-anchor-id="nps-projects">NPS Projects</h2>
<section id="sunrise-visitor-center-water-supply-assessment" class="level3">
<h3 class="anchored" data-anchor-id="sunrise-visitor-center-water-supply-assessment">Sunrise Visitor Center Water Supply Assessment</h3>
<p>As part of a research project at Mount Rainier National Park, I conducted a comprehensive assessment of the water supply system for the Sunrise Visitor Complex, which relies on Frozen Lake and a small 22-acre alpine watershed. My work focused on data-driven analysis of over a decade of water use records, hydrologic and climatic datasets, and historical engineering documents. I developed a remote sensing workflow to remotely monitor future lake levels, constructed a predictive model of seasonal runoff under future climate scenarios, and evaluated alternative groundwater development using geospatial and geophysical data. This project integrated legal, physical, and ecological constraints to produce actionable recommendations, and demonstrated my ability to apply advanced analytical methods to real-world water resource challenges.</p>
<div class="flex" data-gap="4">
<p><img src="images/frozen_ert.png" class="img-fluid" style="width:100.0%"> <img src="images/frozen_model.png" class="img-fluid" style="width:100.0%"></p>
</div>
</section>
<section id="well-database-demo" class="level3">
<h3 class="anchored" data-anchor-id="well-database-demo">Well Database Demo</h3>
<p>I created this <a href="https://dougdunn.shinyapps.io/NPSwells/">Well Database ShinyApp</a> demo for the National Park Service to showcase a simple option to create a user interface that could host a database for groundwater wells and link those wells to water level measurements in NWIS (if available).</p>
<p>Ultimately it was decided to host the user interface as a custom ArcGIS Experience that I created, to allow for the well database to be incorporated into a number of other NPS AGO Webmaps and Experiences.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/well_db.png" class="img-fluid figure-img" width="954"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="tracking-water-storage-in-frozen-lake" class="level3">
<h3 class="anchored" data-anchor-id="tracking-water-storage-in-frozen-lake">Tracking Water Storage in Frozen Lake</h3>
<p>As part of the Water Supply investigation at Mount Rainier National Park I combined depth measurements made by park staff with USGS DEM data to create a new storage rating curve for Frozen Lake.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/frozen_lake.png" class="img-fluid figure-img" width="440"></p>
</figure>
</div>
</div>
</div>
<p>I then took this information and created a function that would download the most recent cloud free landsat imagery, process the imagery to determine the surface area of the lake, and use the surface area to estimate the amount of water currently stored in reservoir. This allows the park to have frequent measurements of storage without the need for additional staff time or equipment.</p>
</section>
<section id="water-supply-well-reports" class="level3">
<h3 class="anchored" data-anchor-id="water-supply-well-reports">Water Supply Well Reports</h3>
<p>I compiled a number of reports on several water supply wells in use by the National Park Service. This was a large amount of data, as the water levels had been recorded at 15 to 30 minute intervals for more than 10 years. In addition, I needed to estimate water use based on when water levels were drawn down by the pump in each well. This required creating several functions to identify when the water was being drawn down by the pump, when the water level was recovering after the pump was off, and when water level changes were due to changes in the surrounding groundwater.</p>
<p>This plot of daily water level min, mean, and max is an example of the natural water level (represented by the min water level) and water level drawdown during pumping (represented by the max water level). The mean water level roughly visualizes use, but can be misleading at times.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/mp4_dtw_plot.png" class="img-fluid figure-img" width="432"></p>
</figure>
</div>
</div>
</div>
<p>I was also able classify time periods when the pump was running and summarize this data for each year to compare how operations have changed and if the water use is driven by visitation to the park.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/pump_est.png" class="img-fluid figure-img" width="350"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="csu-projects" class="level2">
<h2 class="anchored" data-anchor-id="csu-projects">CSU Projects</h2>
<section id="poudre-river-flow-forecast" class="level3">
<h3 class="anchored" data-anchor-id="poudre-river-flow-forecast">Poudre River Flow Forecast</h3>
<p>This project used 11 years (2013 to 2023) of monthly data for flows on the Poudre River at the Canyon mouth as well as precipitation, solar radiation, and max temperature for the contributing watershed to generate six different flow prediction models. The models were then fed MACA climate prediction data to predict flows. Finally, I compared the model predictions to the monthly observed flows between Jan 2024 and May 2025.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/poudre_flows.png" class="img-fluid figure-img" width="527"></p>
</figure>
</div>
</div>
</div>
<p>These models highlight the variability and difficulty with predicting runoff in human managed streams, as you can clearly see the influence of downstream water deliveries occurring in fall.</p>
</section>
<section id="covid-19-spread-and-case-estimates" class="level3">
<h3 class="anchored" data-anchor-id="covid-19-spread-and-case-estimates">COVID-19 Spread and Case Estimates:</h3>
<p>For this project I looked at COVID cases and deaths across the country, tracked how they changed over time and space, and created a linear regression model to estimate new cases where data was unavailable.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/lab1_modelresults.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="remote-sensing-based-flood-inundation" class="level3">
<h3 class="anchored" data-anchor-id="remote-sensing-based-flood-inundation">Remote Sensing based Flood Inundation</h3>
<p>This project looked at the flooding event that took place in Palo, Iowa in September of 2016. Using landsat imagery, I developed a classification threshold from a number of indices to identify flooded areas, which were then plotted on an interactive map to compare against some of the known flood areas.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/palo_floodmap.png" class="img-fluid figure-img" width="378"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="repeatable-flow-prediction-workflows" class="level3">
<h3 class="anchored" data-anchor-id="repeatable-flow-prediction-workflows">Repeatable Flow Prediction Workflows</h3>
<p>For this project I worked with the CAMELS dataset to test a number of attributes to be used as predictors for flow (Q) in a number of different models. The goal was to not only create a successful model (R-squared &gt; 0.9), but to also create a workflow in tidymodels that can evaluate and tune a number of different model types efficiently. For this case, the neural net model was the best pick, but since it was a neural net model it was difficult to identify what attributes had been the most important in model.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="images/nn_model.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="other-projects" class="level2">
<h2 class="anchored" data-anchor-id="other-projects">Other projects</h2>
<section id="irrigation-ditch-companies" class="level3">
<h3 class="anchored" data-anchor-id="irrigation-ditch-companies">Irrigation Ditch Companies</h3>
<p>While working on the City of Boulder’s water supply team, I held several positions with different Irrigation Ditch Companies that the City had an ownership or interest in. My duties varied, but for several companies I developed websites to provide education and outreach materials, provide shareholders with company information, and host real time data availability data.</p>
<p><a href="https://www.andersonditchcompany.com">Anderson Ditch Company Website</a></p>
<p><a href="https://www.farmersditchcompany.com">Farmers Ditch Company Website</a></p>
</section>
<section id="city-of-boulder-irrigation-ditch-education-and-outreach" class="level3">
<h3 class="anchored" data-anchor-id="city-of-boulder-irrigation-ditch-education-and-outreach">City of Boulder Irrigation Ditch Education and Outreach</h3>
<p>As part of my role at the City of Boulder, I led Education and Outreach efforts related to water rights, water supply, and Irrigation Ditch operations. To provide information about these complex topics, I developed a number of documents for City Staff and the public.</p>
<p><a href="https://bouldercolorado.gov/sites/default/files/2021-01/2016-11-09ditchfaq.pdf">Irrigation Ditch FAQ</a></p>
</section>
<section id="flood-recovery-on-st.-vrain-creek" class="level3">
<h3 class="anchored" data-anchor-id="flood-recovery-on-st.-vrain-creek">2013 Flood Recovery on St.&nbsp;Vrain Creek</h3>
<p>While working at Boulder County Parks &amp; Open Space I had the opportunity to work on a number of stream restoration, fish passage, and emergency flood recovery projects. This experience shaped my career by allowing me to rapidly gain experience in project management.</p>
<p><a href="https://bouldercounty.gov/open-space/management/flood-recovery-projects/">2013 Flood Recovery Projects</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>